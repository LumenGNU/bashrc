#!/bin/bash

# @see: https://en.wikipedia.org/wiki/ANSI_escape_code
# @see: https://wiki.archlinux.org/title/Bash/Prompt_customization

# @see: https://gogh-co.github.io/Gogh/

# font-powerline
# font-awesome

# declare -r LOGFILE=/run/user/1000/bppp.log
# echo "" >> $LOGFILE
# echo "ppp_command loadeed . . . . . . . . . . . . . . " >> $LOGFILE

declare BPPP_ERR_LINE=''
declare BPPP_CUR_SUBDIR=''
declare BPPP_CUR_BRH=''

declare -i BPPP_CCOUNTER=0

# declare -i BPPP_TIMESTAMP=0

# declare BPPP_COLOR_USER=''
# declare BPPP_COLOR_HOST=''
declare BPPP_CF_SUBDIR=''

# функция рисует инф-строку после выполнения комманды. Типа такой:
# ‾[1:23:57]‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾ 0  0  2‾
#               отделяющая линия -^
#  ^-- время выполнения команды (отображается если >5c)
#                                        коды завершения комманд(ы)  -^
## ubppp_print_nfo_line timestamp errCode1 errCode2 ... errCodeN
function ubppp_print_nfo_line { # @mark function ubppp_print_nfo_line
  local -i _padding=1
  local _err_line=''

  local _timestamp="$1"
  shift
  if ((_timestamp > 5)); then
    # timestamp to hh:mm:ss
    printf -v _timestamp "[%02d:%02d:%02d]" "$((_timestamp / 60 / 60))" "$(((_timestamp / 60) % 60))" "$((_timestamp % 60))"
    ((_padding = _padding + ${#_timestamp}))
  else
    _timestamp=''
  fi #< первый параметр обработан сохранен в _timestamp, и отброшен (shift)

  local _err_line_len="$*"
  _err_line_len=${_err_line_len// /}
  _err_line_len=${#_err_line_len} #< длинна всех символов всех параметров исключая пробелы

  for n in "$@"; do #< перебор всех параметров (коды завершения)
    # и составление одной раскрашеной строки
    if ((n == 0)); then
      # _err_line="${_err_line}\e[0;38;5;193;48;5;34m $n " #< нулевой код (fg св-зеленый, bg зеленый)
      _err_line="${_err_line}\e[38;5;34;49m $n " #< нулевой код (fg св-зеленый, bg по умолчанию)
    else
      # _err_line="${_err_line}\e[0;38;5;225;48;5;196m $n " #< не нулевой код (fg св-красный, bg красный)
      _err_line="${_err_line}\e[38;5;196;49m $n " #< не нулевой код (fg св-красный, bg по умолчанию)
    fi
    ((_padding = _padding + 2))
  done

  tput sgr0 #< рисование инф-строки
  # stty -g >> $LOGFILE

  printf '\n'
  # не работает в vscode
  # # серый цвет----v + Overlined
  printf '\e[38;5;239;53m %s' "${_timestamp}"
  printf '%*s' $((COLUMNS - 1 - _err_line_len - _padding)) ''
  printf '%b\e[0m' "${_err_line}"
  printf '\n\n'
  tput sgr0
}

function ubppp_print_progect_dir { # @mark function ubppp_print_progect_dir
#@fixme: Если commanprompt вывелся в первой строке перерисовать все заново

  # получить путь к корню репозитория
  local BPPP_TOPLEVEL
  BPPP_TOPLEVEL="$(git rev-parse --show-toplevel 2>/dev/null)"

  { [[ -z "${BPPP_TOPLEVEL}" ]] && local -r IS_GIT_FLAG=''; } || local -r IS_GIT_FLAG='yes'
  # если BPPP_TOPLEVEL не пустая -- внутри git репозитория

  # если это не репозитортй значит текущая папка -- просто текущая папка
  local -r PWD="$(pwd -P)"
  BPPP_TOPLEVEL=${BPPP_TOPLEVEL:-"${PWD}"}

  # цвет для текущего текста каталог/репозиторий, зависит от того есть ли
  # разрешение на запись в каталог/репозиторий
  {
    [[ -w "${PWD}" ]] && printf -v BPPP_CF_SUBDIR '\e[38;5;228m' #< есть
  } || printf -v BPPP_CF_SUBDIR '\e[38;5;196m'                   #< нет

  { [[ -z "${IS_GIT_FLAG}" ]] && local icon='\uf07b'; } || #< обычный каталог
    local icon='\uf1d3' #'\uf1d2' #'\uf841' #'\uf121'                                    #< git репозиторий
  printf '\e[0;48;5;53m%b %b ' "${BPPP_CF_SUBDIR}" ${icon}
  unset icon

  local _COLUMNS=$((COLUMNS - 5))
  # распечатать текущий каталог/репозиторий, обрезав начало если не помещается
  # в одну строку
  ((${#BPPP_TOPLEVEL} > COLUMNS)) && BPPP_TOPLEVEL="…${BPPP_TOPLEVEL: -$_COLUMNS:$_COLUMNS}"
  printf ' %-*s\e[0m\n' "${_COLUMNS}" "${BPPP_TOPLEVEL}" #&& tput sgr0

  if [[ -n "${IS_GIT_FLAG}" ]]; then # git
    # текущий подкаталог текущего проекта(репозитория).
    BPPP_CUR_SUBDIR="${PWD#"${BPPP_TOPLEVEL}"}"

    if ((${#BPPP_CUR_SUBDIR} > 25)); then
      BPPP_CUR_SUBDIR="…${BPPP_CUR_SUBDIR: -25:25}"
      BPPP_CUR_SUBDIR="./${BPPP_CUR_SUBDIR}"
    else
      BPPP_CUR_SUBDIR=".${BPPP_CUR_SUBDIR:-/}"
    fi

    # текущая ветка репозитория
    BPPP_CUR_BRH="$(git branch --show-current 2>/dev/null)"
    BPPP_CUR_BRH="${BPPP_CUR_BRH:-"* * *"}" # @fixme: точно нужно?
  else                                      # no git
    BPPP_CUR_BRH=''
    BPPP_CUR_SUBDIR=''
  fi

  tput sgr0 # TODO FIME:
}

# строит строку user@host
# цвет красный если user == root, и если host --> ssh
function ubppp_print_user_host { # @mark function ubppp_print_user_host
  # @fixme: протестировать
  # юзер
  if (("$EUID" == 0)); then
    printf "\1\e[49;38;5;196m\2" #< если root
  else
    printf "\1\e[49;38;5;228m\2" #< если нет
  fi
  printf '%s\1\e[0m\2@' "${USER}" #< разделитель
  # хост
  # @todo [ или [[
  if [ -n "${SSH_CLIENT}" ] || [ -n "${SSH_TTY}" ] || [ -n "${SSH_CONNECTION}" ]; then
    printf "\1\e[49;38;5;196m\2" #< если локальный
  else
    printf "\1\e[49;38;5;228m\2" #< если ssh
  fi
  printf '%s\1\e[0m\2 ' "${HOSTNAME}"
}

function ubppp_print_branch { # @mark function ubppp_print_branch
  if [ -n "${BPPP_CUR_BRH}" ]; then
    if [ "${BPPP_CUR_BRH}" = "master" ] || [ "${BPPP_CUR_BRH}" = "main" ]; then
      local cf_brh='\e[49;4;58;5;228'
    else
      local cf_brh='\e[49;4;58;5;196'
    fi
    if [ "$(git status --porcelain 2>/dev/null | wc -l)" = "0" ]; then
      cf_brh="${cf_brh};38;5;228m"
    else
      cf_brh="${cf_brh};38;5;196m"
    fi
    local stage_count="$(git stash list 2>/dev/null | wc -l)"
    if [ "${stage_count}" = "0" ]
    then
      stage_count=''
    else
      stage_count="{${stage_count}}"
    fi
    printf '\1%b\2%s\1\e[0m\2%s \1%b\2%s\1\e[0m\2 ' "${cf_brh}" "${BPPP_CUR_BRH}" "${stage_count}" "${BPPP_CF_SUBDIR}" "${BPPP_CUR_SUBDIR}"
  fi #---
}

function ubppp_print_brc { # @mark function ubppp_print_brc
  if (("$EUID" == 0)); then
    printf '\1\e[49;38;5;196m\2❯\1\e[0m\2 ' #< если root
  else
    printf '\1\e[49;38;5;228m\2❯\1\e[0m\2 ' #< если нет
  fi
}

function bppp_trap_precommand { # @mark function bppp_trap_precommand
  local -r ERR=${PIPESTATUS[*]}

  ((++BPPP_CCOUNTER))

  # echo " "                                     >> $LOGFILE
  # echo "bppp_trap_precommand *******************"  >> $LOGFILE
  # echo ">    BASH_COMMAND  = ${BASH_COMMAND}"  >> $LOGFILE
  # echo ">    BPPP_CCOUNTER = ${BPPP_CCOUNTER}" >> $LOGFILE
  # echo "ERR      = ${ERR}" >> $LOGFILE
  # echo "BPPP_FLAG  = ${BPPP_FLAG}" >> $LOGFILE

  [[ "${BASH_COMMAND}" == "trap 'bppp_trap_precommand' DEBUG" ]] && { # все команды выполнены
    # BPPP_TIMESTAMP=$(($(date +%s) - BPPP_TIMESTAMP))              #< время выполнения команды # @todo: использовать $SECONDS
    BPPP_ERR_LINE="${ERR}"
    return
  }
  [[ "${BASH_COMMAND}" == "bppp_postcommand" ]] && {
    return
  }

  # if ((BPPP_CCOUNTER == 1)); then
  #   tput sgr0                       #< линия разделитель # @-todo PS0
  #   printf '%b' '\e[49;38;5;239;9m' # 53 | 9
  #   printf '%*s' $((COLUMNS - 1)) ''
  #   printf '\n%b' '\e[0m'
  #   tput sgr0 #<

  #   # echo "!сброс, рисую полоску" >> $LOGFILE

  #   # BPPP_TIMESTAMP=$(date +%s) #< время начала выполнения команды
  #   SECONDS=0
  # fi
  ((BPPP_CCOUNTER == 1)) && SECONDS=0

  # поменять заголовок окна на текущую команду
  printf '\033]0;%s\a' "${USER}@${HOSTNAME}> ${BASH_COMMAND:0:25}"

}

function bppp_precommand { # @mark function bppp_precommand
    tput sgr0                       #< линия разделитель
    printf '%b' '\e[49;38;5;239;9m' # 53 | 9
    printf '%*s' $((COLUMNS - 1)) ''
    printf '\n%b' '\e[0m'
    tput sgr0 #<

    # echo "!сброс, рисую полоску" >> $LOGFILE

    # BPPP_TIMESTAMP=$(date +%s) #< время начала выполнения команды
    # SECONDS=0 #< @-bug: тут не работает
}

function bppp_postcommand { # @mark function bppp_postcommand
  # echo "bppp_postcommand *******************************************" #>> $LOGFILE
  # echo ">    BPPP_CCOUNTER = ${BPPP_CCOUNTER}"                              #>> $LOGFILE

  tput rmso
  
  if ((BPPP_CCOUNTER > 2)) && [[ -n "${BPPP_ERR_LINE}" ]]; then
    # shellcheck disable=SC2086
    ubppp_print_nfo_line "${SECONDS}" ${BPPP_ERR_LINE}
    BPPP_ERR_LINE=''
  else
    printf '%b' "\033[s\033[2A" #< если нет команды (ентер в пустой строке)
    #< перед рисованием сдвинутся вверх 2строки
  fi

  ubppp_print_progect_dir

  BPPP_CCOUNTER=0
  # echo "" >> $LOGFILE
}

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
  debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
xterm-color | *-256color) color_prompt=yes ;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
  if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
    # We have color support; assume it's compliant with Ecma-48
    # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
    # a case would tend to support setf rather than setaf.)
    color_prompt=yes
  else
    color_prompt=
  fi
fi

DEB_CHROOT=${debian_chroot:+($debian_chroot)}

# see: https://wiki.archlinux.org/title/Bash/Prompt_customization
# Note: Wrapping the tput output in \[ \] is recommended by the Bash man page.
# This helps Bash ignore non-printable characters so that it correctly
# calculates the size of the prompt. The wrap will not work with command
# substitution, in which case the raw \1 \2 must be used.
if [[ "$color_prompt" = yes ]] &&  [[ "${VSCODE_TERMINAL}" != "yes" ]] ; then
  # @mark: PROMPT_COMMAND=
  PROMPT_COMMAND="trap 'bppp_trap_precommand' DEBUG; bppp_postcommand"
  # @mark PS0=
  # shellcheck disable=SC2016,SC2034
  PS0='$(bppp_precommand)'
  # @mark: PS1=
  PS1='${DEB_CHROOT}$(ubppp_print_user_host)$(ubppp_print_branch)$(ubppp_print_brc)\[\e[0K\]\[\e[0;1m\]'
  #                                                                                 ^-очистить строку от возможного мусора

else
  PROMPT_DIRTRIM=3
  PS1='\n${DEB_CHROOT}\u@\h \w ❯ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm* | rxvt*)
  PS1="\[\e]0;${DEB_CHROOT}\u@\h${BPPP_CUR_SUBDIR}\a\]$PS1"
  ;;
*) ;;

esac
