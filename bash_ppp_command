#!/bin/bash

# Глобальные переменные скрипта
# =============================
# Префикс BPPP_ используется для предотвращения конфликтов имен в глобальном окружении bash

declare -a BPPP_ERR_LINE=() # Массив для хранения кодов возврата команд в цепочке

# @fixme: иследовать возможность использовать переменную bash LINENO
declare -i BPPP_CCOUNTER=0  # Счетчик команд для корректной обработки цепочек команд

# Используется встроенная переменная bash SECONDS как секундомер:
# - Сбрасывается в 0 перед выполнением команды
# - Автоматически увеличивается на 1 каждую секунду
# - Значение передается в bppp_print_nfo_line для отображения времени выполнения

# Сокращает длинные пути для улучшения читаемости промпта
# Пример: /very/long/path/to/somewhere -> …/to/somewhere
#
# $1 - исходный путь
# $2 - максимальная длина результата
function bppp_truncate_path() {
    local path="$1"
    local max_len="$2"
    if ((${#path} > max_len)); then
        echo "…${path: -$max_len:$max_len}"
    else
        echo "$path"
    fi
}

# Форматирует и выводит информационную строку после выполнения команды/цепочки команд.
# Ета строка содержит:
# - Время выполнения (если больше 5 секунд) в формате [ЧЧ:ММ:СС]
# - Коды возврата всех команд в цепочке
# - Маркер '=' при потере кодов возврата в длинных цепочках
#
# Особенности форматирования:
# - Восстанавливает нормальное состояние терминала перед выводом
# - Использует Overlined стиль для визуального разделения
# - Правое выравнивание кодов возврата
# - Цветовая индикация успешности (0 - зеленый, иначе - красный)
#
# @param $1 - время выполнения в секундах
# @param $@ - коды возврата команд (включая возможный маркер '=')
function bppp_print_nfo_line() {

  # Сброс/исправление терминала после выполнения команды.
  # @fixme: Может заменить на tput sgr0? @decision: Не изменять, так как текущий вариант стабильнее.
  printf '\e(B\e[00m'

  # Суммарная длина всех фиксированных элементов в строке
  local -i _fixed_width=1 # ... начиная с "начальный отступ от левого края"
  
  local _err_line='' # Строит отформатированную подстроку с кодами возврата

  # Первый аргумент - время выполнения команды
  local _timestamp="$1" # ... сохраняется
  shift                 # ... и отбрасывается
                        # Теперь "$@" содержит только коды возврата
  
  # @fixme: Вынести магическое число 5 в именованную константу
  if ((_timestamp > 5)); then
    # Форматируем временной интервал (timestamp) в [ЧЧ:ММ:СС]
    # если команда выполнялась дольше N секунд
    printf -v _timestamp "[%02d:%02d:%02d]" \
        "$(( _timestamp / 60 / 60 ))" \
        "$(( (_timestamp / 60) % 60 ))" \
        "$(( _timestamp % 60 ))"
        
    (( _fixed_width = _fixed_width + ${#_timestamp} ))
  else
    _timestamp=''
  fi

  # Расчет длины строки с кодами возврата (без пробелов)
  local _err_line_len="$*"           # Все аргументы в одну строку
  _err_line_len=${_err_line_len// /} # Удаляем все пробелы
  _err_line_len=${#_err_line_len}    # Получаем длину

  # Составление одной раскрашенной строки с кодами возврата (каждый код окружен пробелом)
  for n in "$@"; do          # перебор всех параметров (коды завершения)

    # @fixme: Проверить необходимость проверки пустых параметров. 
    # По текущей логике пустые параметры не должны появляться:
    # - SECONDS (встроенная переменная bash) всегда числовая
    # - BPPP_ERR_LINE содержит только коды возврата
    # - _mark либо "= " либо пропадает при подстановке
    if [[ -n "${n}" ]]; then # пропуск возможного пустого параметра

      # и составление одной раскрашенной строки
      if [[ "${n}" = "=" ]]; then
        _err_line+="\e[38;2;${BPPP_COLORS[1]}m\e[49m $n " #< маркер "="
      elif ((n == 0)); then
        _err_line+="\e[38;2;${BPPP_COLORS[3]}m\e[49m $n " #< нулевой код (fg св-зеленый, bg по умолчанию)
      else
        _err_line+="\e[38;2;${BPPP_COLORS[4]}m\e[49m $n " #< не нулевой код (fg св-красный, bg по умолчанию)
      fi
      (( _fixed_width += 2 ))
    fi
  done

  printf '\n'
  # Вывод в формате: [ЧЧ:ММ:СС]<заполнитель-до-правого-края><коды-возврата>
  # Вся строка отображается с форматированием Overline ( \e[53 )
  printf '%b %s' "\e[53;38;2;${BPPP_COLORS[1]}m\e[49m" "${_timestamp}" # Время выполнения
  printf '%*s' $(( COLUMNS - 1 - _err_line_len - _fixed_width )) ' '             # Заполнение пространства вправо
  printf '%b%b' "${_err_line}" "\e[0m"                                   # Коды возврата и сброс форматирования
  printf '\n\n'
}

# Обработчик trap DEBUG для отслеживания выполнения пользовательских команд.
# Вызывается перед каждой командой в цепочке команд командной строки.
# @todo: Добавить дополнительную визуальную разделительную линию 
# для команд, запускаемых через sudo, чтобы явно выделять 
# команды с повышенными привилегиями
# @todo: Добавить дополнительную визуальную разделительную линию для sudo команд:
# 1. Установить флаг при обнаружении sudo в BASH_COMMAND
# 2. В bppp_print_precommand использовать другой стиль линии если флаг установлен
# @fixme: Упростить логику сохранения PIPESTATUS, перенеся её непосредственно 
# в PROMPT_COMMAND: "BPPP_ERR_LINE=(${PIPESTATUS[*]}) ;trap ... "
function bppp_trap_precommand() {

  # @fixme: если trap - DEBUG можно убрать, то последующий код не влияет на PIPESTATUS.
  # Это также позволит избавиться от промежуточной переменной _err_status

  # Сохраняем коды возврата на момент входа в функцию,
  # т.к. PIPESTATUS изменится при выполнении следующих команд
  # @fixme: Использовать mapfile/read -a вместо прямого присваивания массива
  # @fixme: переименовать на _status_buffer
  local -ar _err_status=(${PIPESTATUS[*]})

  trap - DEBUG # @fixme: Проверить необходимость сброса trap

  # Пропускаем обработку служебных команд промпта
  case "${BASH_COMMAND}" in
  "bppp_postcommand")
    return
    ;;
  "trap 'bppp_trap_precommand' DEBUG")
    # Сохраняем коды возврата пользовательских команд для последующего вывода
    # @fixme: Использовать mapfile/read -a вместо прямого присваивания массива
    BPPP_ERR_LINE=(${_err_status[*]}) #запомнить коды завершений
    return
    ;;
  esac

  # Обновление заголовка окна терминала текущей командой
  printf '\e]0;%s\a' "${debian_chroot:+($debian_chroot)}${SSH_CONNECTION:+SSH:}${USER}@${HOSTNAME} 〉 ${BASH_COMMAND:0:25}"

  # Управление счетчиком команд и таймером
  (( BPPP_CCOUNTER == 0 )) && SECONDS=0 # обнуление таймера перед первой командой
  (( ++BPPP_CCOUNTER )) # подсчет команд
}

# Обработчик завершения пользовательских команд.
# Вызывается через PROMPT_COMMAND после выполнения всех команд.
#
# Функционал:
# - Восстанавливает заголовок терминала
# - Отображает результаты выполнения команд через bppp_print_nfo_line:
#   - время выполнения
#   - коды возврата
#   - маркер '=' при потере кодов в множественных конвейерах
# - Сбрасывает счетчики для следующего ввода
function bppp_postcommand() {

  # сбросить заголовок окна
  printf '\e]0;%s\a' "${debian_chroot:+($debian_chroot)}${SSH_CONNECTION:+SSH:}${USER}@${HOSTNAME}"

  if ((BPPP_CCOUNTER > 0)); then

    # Проверка на потерю кодов возврата при нескольких конвейерах через ;
    # Пример: cmd1|cmd2 ; cmd3|cmd4  -- PIPESTATUS сохранит только коды для cmd3|cmd4
    { ((BPPP_CCOUNTER > ${#BPPP_ERR_LINE[@]})) && local -r _mark='= '; } || local -r _mark=''

    # shellcheck disable=SC2086,SC2048
    bppp_print_nfo_line "${SECONDS}" ${_mark} ${BPPP_ERR_LINE[*]} # вывести строку статуса
    BPPP_ERR_LINE=('')

    BPPP_CCOUNTER=0 # сбросить счетчик команд
  else
    # Пустая строка (Enter без команды или C-c)
    # @fixme: Попытки уменьшить кол-во пустых строк через прокрутку 
    # терминала приводят к побочным эффектам
    # printf '\e[2A'  # Переместить курсор на 2 строки вверх
    # printf '\e[0J'  # Очистить экран от курсора до конца
    :
  fi

}

# Визуально создает эффект разделительной линии между строкой ввода команды и её выводом.
# Функция вызывается через PS0 перед выводом результатов команды.
# Использует Overlined стиль для экономии вертикального пространства.
function bppp_print_precommand() {

  # Линия через Overlined стиль на всю ширину терминала минус 1 символ
  printf '%b%*s%b\n' "\e[53;38;2;${BPPP_COLORS[1]}m\e[49m" "$(( ${COLUMNS:-$(tput cols)} - 1 ))" ' ' "\e[0m" 
  printf '\e[J' #< Очистка до конца экрана для предотвращения артефактов подсветки

  # @note: поменять заголовок окна на текущую команду тут не получится
}


# Формирует двустрочный prompt командной строки:
# - Текущий каталог/репозиторий с возможностью перехода по клику
# - Информация о git (ветка, статус изменений)
# - Различное оформление для каталогов с правами и без прав на запись
#
# Первая строка:
# - Текущий путь/репозиторий с поддержкой перехода по клику
# - Усечение длинных путей для компактного отображения
# - Цветовая индикация прав на запись
#
# Вторая строка:
# - user@host с индикацией root-пользователя и SSH-соединения
# - Для git-репозитория с правами на запись:
#   * имя ветки (подчеркнуто если не main/master)
#   * статус изменений через цвет
#   * количество stash-записей
#   * текущий подкаталог относительно корня репозитория
# - Символ-разделитель и стиль для вводимого текста
#
# Использует специальные маркеры \1 и \2 для корректного 
# подсчета длины промпта bash'ем
function bppp_print_prompt() {

  # Определяем контекст текущего каталога:
  # - Для git репозитория: путь к его корню
  # - Для обычного каталога: текущий путь
  # @fixme: SC2155 – Разделить объявление и присваивание переменных для безопасности
  # @fixme: Переработать логику определения is_git-контекста:
  # - Инициализировать переменную до if
  # - Использовать более явные true/false значения
  # - Выбрать более говорящее имя переменной
  # @fixme: Обьявлять переменные вне блока if, замораживать, при необходимости командой readonly
  if git rev-parse --is-inside-work-tree &>/dev/null; then
    # Находимся внутри git репозитория
    local -r is_git=1
    # Получаем путь к корню репозитория с сохранением символических ссылок
    # @fixme: Проверить необходимость сложной конструкции с cd+pwd 
    #         вместо простого git rev-parse --show-toplevel
    local _bppp_toplevel="$(cd "$(git rev-parse --show-cdup 2>/dev/null)." && pwd 2>/dev/null)" # так надо если каталог символ. ссылка
  else
    # Обычный каталог
    local _bppp_toplevel="$(pwd 2>/dev/null)"
  fi

  # Установка цвета фона. \1 и \2 маркируют невидимые символы форматирования,
  # чтобы bash правильно рассчитывал длину промпта для позиционирования курсора
  printf '\1%b\2' "\e[0;48;2;${BPPP_COLORS[0]}m"

  # Цвет текста зависит от прав на запись в текущий каталог
  # @fixme: Избыточное использование readonly флага для временных переменных форматирования
  # @fixme: Обьявлять переменные вне блока if, замораживать, при необходимости командой readonly
  # @fixme: Переименовать переменные _bppp_cf_* в более понятные:
  #         - cf видимо означает "color format"
  #         - prjdir = "project directory"?
  #         - subdir = "subdirectory"
  if [[ -w "${PWD}" ]]; then
    # Каталог доступен для записи
    local -r _bppp_cf_prjdir="\e[38;2;${BPPP_COLORS[5]};1m" #< есть
    local -r _bppp_cf_subdir="\e[38;2;${BPPP_COLORS[5]}m"   #< есть
  else
    # Каталог только для чтения
    local -r _bppp_cf_prjdir="\e[38;2;${BPPP_COLORS[6]};1m" #< нет
    local -r _bppp_cf_subdir="\e[38;2;${BPPP_COLORS[6]}m"   #< нет
  fi

  # Вывод первой строки промпта с полным путем
  # @fixme: Вынести создание терминальной ссылки в отдельную функцию terminal_link
  # @fixme: Исправить формирование ссылки: использовать полный путь вместо обрезанного
  # @fixme: Создать отдельную переменную для обрезанного пути вместо перезаписи _bppp_toplevel
  printf '\1%b\2' "${_bppp_cf_prjdir}" # Установка стилей

  # Ограничение длины отображаемого пути
  # @fixme: Магическое число 6 - пояснить или вынести в именованную константу
  # @fixme: Нужна ли тут переменная _columns вооще?
  local -r _columns=$((COLUMNS - 6)) # Отступ для эстетического оформления
  # Путь должен обрезатся если не помещается в одну строку
  # @fixme: при формировании ссылки используется _bppp_toplevel, т.е. обрезанный путь -- что скорее всего ошибка. И вообще зачем был перезаписан _bppp_toplevel?
  # @fixme: Предлагается:
  # - Использовать отдельную переменную для обрезанного пути
  # - В ссылке использовать оригинальный путь
  # @fixme: Можно вообще обойтись без промежуточных переменных
  _bppp_toplevel="$(bppp_truncate_path "$_bppp_toplevel" "$_columns")"
  
  # Вывод пути с поддержкой перехода по клику
  # format: \e]8;;URL\e\\VISIBLE_TEXT\e]8;;\e\\
  # '\e[K' - заполнение фоном до конца строки
  printf '\1%b%b%b\2\n' "\e]8;;file://${HOSTNAME}${_bppp_toplevel}\e\\\\\2${_bppp_toplevel}\1\e]8;;\e\\" '\e[K' '\e[0m'

  # Форматирование user@host с индикацией типа пользователя (root/обычный)
  # и наличия SSH-соединения
  # @fixme: Переименовать _user_af в более понятное имя (af = attribute format?)
  # @fixme: Вынести объявление переменной за пределы if:
  #   local _user_style
  #   if ...; then
  #     _user_style=... && readonly _user_style
  #   else
  #     _user_style=... && readonly _user_style
  #   fi
  if (("$EUID" == 0)); then
    local -r _user_af="\e[49;38;2;${BPPP_COLORS[9]}m" #< если root
  else
    local -r _user_af="\e[49;38;2;${BPPP_COLORS[8]}m" #< если нет
  fi
  # Вывод "user@host" с добавлением "SSH:" при подключении через SSH
  # @fixme: Перенести индикатор SSH на сторону хоста: user@SSH:host
  # Это будет логичнее и не разбивает стандартный формат user@host
  printf '\1%b\2%s\1%b\2@' "${_user_af}" "${SSH_CONNECTION:+SSH:}${USER}" "\e[0;38;2;${BPPP_COLORS[8]}m"
  # хост
  printf '%s\1%b\2 ' "${HOSTNAME}" "\e[0m"

  # Отображение git-информации только если:
  # - Текущий каталог в git-репозитории
  # - Есть права на запись (иначе работа с репозиторием невозможна)
  if [[ ${is_git:-0} == 1 ]] && [[ -w "${PWD}" ]]; then # git и есть разрешение на запись

    # Определение текущей ветки репозитория
    # @fixme: Общая проблема: SC2155 – Declare and assign separately
    # @fixme: Заменить ***** на ??????? как более интуитивный индикатор
    # отсутствия текущей ветки (detached HEAD и т.п.)
    local _bppp_cur_brh="$(git branch --show-current 2>/dev/null)"
    _bppp_cur_brh="${_bppp_cur_brh:-"*****"}" # Заполнитель для состояний без активной ветки (detached HEAD и т.п.)

    # Установка стиля для имени ветки:
    # - Подчеркивание для веток отличных от main/master
    # @fixme: Вынести main/master в конфигурируемый список основных веток
    if [ "${_bppp_cur_brh}" != "master" ] && [ "${_bppp_cur_brh}" != "main" ]; then
      printf '\1%b\2' "\e[49;4:1;58;2;${BPPP_COLORS[9]}m" #< не main/master
    fi

    # Установка цвета текста в зависимости от состояния ветки
    # @fixme: Рассмотреть использование полного стиля вместо только цвета
    if [ "$(git status --porcelain 2>/dev/null | wc -l)" = "0" ]; then
      printf '\1%b\2' "\e[38;2;${BPPP_COLORS[8]}m" # Нет изменений
    else
      printf '\1%b\2' "\e[38;2;${BPPP_COLORS[9]}m" # Есть несохраненные изменения
    fi

    # Вывод имени ветки и сброс форматирования
    printf '%s\1%b\2' "${_bppp_cur_brh}" "\e[0m"
    
    # Отображение количества stash-записей, если они есть
    # @fixme: Переименовать _stage_count в _stash_count
    # @fixme: SC2155 – Declare and assign separately
    # @fixme: Рассмотреть выделение количества stash-записей через стили 
    #         вместо обрамления фигурными скобками
    local _stage_count="$(git stash list 2>/dev/null | wc -l)"
    if [[ "${_stage_count}" != "0" ]]; then
      printf '{%s}' "${_stage_count}" # Скобки для визуального выделения
    fi

    # Отображение текущего подкаталога относительно корня репозитория
    # @fixme: Магическое число 25 - максимальная длина отображаемого пути
    # @fixme: './' как префикс не очень удачен, хотя идея правильная - 
    #         нужно визуально показать, что это относительный путь внутри репозитория
    #         …/ ▸ → : ≫
    #         Заменить './' на '…/' для единообразия с остальным 
    #         форматированием путей в промпте
    local -r _bppp_cur_subdir="./$(bppp_truncate_path "$(git rev-parse --show-prefix 2>/dev/null)" 25)"

    printf ' \1%b%b\2\1%b\2 ' "${_bppp_cf_subdir}" "\e]8;;file://${HOSTNAME}${PWD}\e\\\\\2${_bppp_cur_subdir}\1\e]8;;\e\\" "\e[0m"
  fi

  # Вывод символа-разделителя и установка стиля для командной строки:
  # - Символ 〉 в том же стиле, что и имя пользователя
  # - Последующий ввод будет отображаться заданным стилем
  printf '\1%b\2%s\1%b\2' "${_user_af}" '〉' \
     "\e[0;1;38;2;${BPPP_COLORS[2]}m"

}


# ТОЧКА ВХОДА ##
# ==============================================================================

# Определение chroot окружения
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
  debian_chroot=$(cat /etc/debian_chroot)
fi

# Базовая настройка промпта
PROMPT_DIRTRIM=3

# Определение типа терминала и настройка промпта:
if [[ -n "$GNOME_TERMINAL_SCREEN" && "$TERM" = "xterm-256color" ]]; then
    # Включаем поддержку true color
    export COLORTERM=truecolor
    
    # Проверяем наличие необходимых команд
    if command -v git >/dev/null && command -v cpp >/dev/null; then
        # Загружаем настройки цветов
        # @todo: Перейти на более простой формат конфигурации
        mapfile -t BPPP_COLORS < <(cpp -P ~/.Xresources.d/ppp.xresources | \
            grep -F 'ppp_theme.Colors.color' | sort | cut -f2 | cut -d' ' -f2)
        
        # Включаем расширенный промпт
        PROMPT_COMMAND="trap 'bppp_trap_precommand' DEBUG; bppp_postcommand"
        PS0='$(bppp_print_precommand)'
        PS1='${debian_chroot:+($debian_chroot)}$(bppp_print_prompt)'
    else
        echo "ppp: Включен базовый режим промпта. " >&2
        command -v git >/dev/null || echo "Не найдена команда git. " >&2
        command -v cpp >/dev/null || echo "Не найдена команда cpp. " >&2
        echo -e "Установите недостающие зависимости для работы расширенного промпта.\n" >&2
        PS1='\n${debian_chroot:+($debian_chroot)}\u@\h:\w\ 〉'
    fi
elif [[ "${TERM_PROGRAM}" == "vscode" ]]; then
    # Цветной промпт для VSCode
    PS1='\[\e[0;1m\]\n${debian_chroot:+($debian_chroot)}\[\e[32m\]\u@\h\[\e[0m\]:\[\e[34m\]\w 〉\[\e[0m\]'
else
    # Простой промпт для остальных терминалов
    PS1='\n${debian_chroot:+($debian_chroot)}\u@\h:\w\ 〉'
fi
